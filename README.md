# crazy-bill-splitter

## これは何

「割り勘 精算」でググると様々な精算アプリが見つかります。しかし、どのようなアルゴリズムを使って精算の処理を行っているのかは不透明です。
そこで、テストケースを再利用可能な形で定義し、最適なアルゴリズムを使っているかを調査しやすくする目的で作ったレポジトリです。

## ディレクトリ構成

```bash
$ tree -L 2
.
├── README.md: このファイルです。
├── apps: 精算処理を行うWEB APIを実装するためのディレクトリです。
│   └── python: Python/FastAPIによる実装例です。
├── docker-compose.yml: テストアプリケーションとapps/pythonサーバーを立ち上げるための設定ファイルです。
├── openapi.yml: 精算APIの定義ファイルです。
└── test: テストを定義するためのディレクトリです。
```

### apps

`openapi.yml` で定義されているインターフェイスに基づいた精算処理を行うWEB APIの実装を入れるためのディレクトリです。
例としてPython/FastAPIによる実装を用意しています。別言語による実装も歓迎しています！

#### 実装例で使っているアルゴリズム

ベースのアプローチとして、貪欲法的に最大債務者が最大債権者に対して支払えるだけ支払うというアルゴリズムを使っています [^1]。
例えば以下のようにA, B, C, D, Eの5名で以下のように建て替えたケースを考えてみましょう。

```
Aが全員分の高速代 2,000円を支払った
Bが全員分の昼食代 10,000円を支払った
Cが全員分の夕食代 20,000円を支払った
```

このとき、割り勘金額は6,400円なので、各々が支払う/受け取るべき金額は以下の通りです。

```
A: 4,400円を支払う
B: 3,600円を受け取る
C: 13,600円を受け取る
D: 6,400円を支払う
E: 6,400円を支払う
```

受け取る人も支払う人も複数人いるので、誰が誰に払うべきか迷いますね。
そこで、[^1] のアルゴリズムを適用します。
最大債務者はD [^2] で、最大債権者であるCに支払います。すると、現時点での送金状況と、未清算リストは以下のようになります。

```
E -> C: 6,400円送金

A: 4,400円を支払う
B: 3,600円を受け取る
C: 7,200円を受け取る
D: 6,400円を支払う
E: 精算完了
```

続いて、現在の最大債務者はD、最大債権者はCなので、同様に適用します。

```
E -> C: 6,400円送金
D -> C: 6,400円送金

A: 4,400円を支払う
B: 3,600円を受け取る
C: 800円を受け取る
D: 精算完了
E: 精算完了
```

次は最大債務者がAで最大債権者はBですが、4400円を送金してしまうとBから更に別の人に送金する必要が発生してしまいます。そこで、Bが受け取るべき金額までを支払います。

```
E -> C: 6,400円送金
D -> C: 6,400円送金
A -> B: 3,600円送金

A: 800円を支払う
B: 精算完了
C: 800円を受け取る
D: 精算完了
E: 精算完了
```

最後にAがCに送金すれば精算が完了します。

```
E -> C: 6,400円送金
D -> C: 6,400円送金
A -> B: 3,600円送金
A -> C: 800円送金

A: 精算完了
B: 精算完了
C: 精算完了
D: 精算完了
E: 精算完了
```

4回の送金、合計送金金額17,200円で精算することができました。このケースではこれ以上送金回数と合計送金金額を減らすことはできません。
では、このアルゴリズムは完璧[^3]なのでしょうか？否、送金回数を最小にできないケースがあります。

言い換えると、最大債務者が最大債権者に支払わないほうが、送金回数を最小にできるということです。
具体的に以下の5人で精算するケースを考えましょう。

```
Aが全員分のhoge代 9,000円を支払った
Bが全員分のfuga代 8,000円を支払った
Cが全員分のpiyo代 3,500円を支払った
Dが全員分のfoo代 2,500円を支払った
Eが全員分のbar代 2,000円を支払った
```

このとき、割り勘金額は5,000円なので各々が支払う/受け取るべき金額は以下の通りです。

```
A: 4,000円を受け取る
B: 3,000円を受け取る
C: 1,500円を支払う
D: 2,500円を支払う
E: 3,000円を支払う
```

[^1] のアルゴリズムを適用します。最大債務者Eが最大債権者Aに送金します。

```
E -> A: 3,000円送金

A: 1,000円を受け取る
B: 3,000円を受け取る
C: 1,500円を支払う
D: 2,500円を支払う
E: 精算済み
```

次に、最大債務者Dが最大債権者Bに送金します。

```
E -> A: 3,000円送金
D -> B: 2,500円送金

A: 1,000円を受け取る
B: 500円を受け取る
C: 1,500円を支払う
D: 精算済み
E: 精算済み
```

続いて、最大債務者Cが最大債権者Aに送金します。

```
E -> A: 3,000円送金
D -> B: 2,500円送金
C -> A: 1,500円送金

A: 精算済み
B: 500円を受け取る
C: 500円を支払う
D: 精算済み
E: 精算済み
```

最後に、最大債務者Cが最大債権者Bに送金して精算が完了します。

```
E -> A: 3,000円送金
D -> B: 2,500円送金
C -> A: 1,500円送金
C -> B: 500円送金

A: 精算済み
B: 精算済み
C: 精算済み
D: 精算済み
E: 精算済み
```

合計4回、合計送金金額7,500円で精算が完了しますが、これよりももっと良い精算方法が存在します。

```
E -> B: 3,000円送金
D -> A: 2,500円送金
C -> A: 2,000円送金
```

最大債務者であるEがAではなくBに送金することで、送金回数を1回減らすことができるのです。
より抽象度を高めると、お釣りなしで送金できるケースがあればそれを優先することで送金回数を減らすことができます。厳密な証明はしていませんが、精算参加者 `N` 名、債務者 `m` 名、債権者 `n` 名のとき、すべての債権者/債務者の金額を債務者/債権者の金額の部分和で表すことができれば、 `MAX(m, n)` の送金回数で精算することができ、部分和で満たせない場合はたかだか `N-1` の送金回数で精算することができます。

部分和で満たせるかどうかを調べるコードは以下のように実装しました。

https://github.com/Tsutomu-Ikeda/crazy-bill-splitter/blob/c33737507c8bc3483010e85f43776e41b9624663/apps/python/src/services/calculate_settlements.py#L32-L89

以上が2024年2月時点でのアルゴリズムとなっています。もし考慮漏れがあればPRやIssueを上げていただけると大変助かります。

[^1]: uetchy 「最小送金回数で精算する割り勘アルゴリズム」 2024年2月3日アクセス
https://uechi.io/blog/split-bill/
[^2]: Eも同額ですが、どちらから支払いを介しても結果は変わりません。
[^3]: 常に送金回数と合計送金金額を最小にできるかどうかという意味合いで使っています。ユースケースによって、送金回数の増加を多少許容しても受け取り者を集約したいという制約が考えられるので、「完璧」を目指すにはもう少し深く検討する必要があります。
